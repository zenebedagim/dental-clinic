// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  RECEPTION
  DENTIST
  XRAY
}

enum AppointmentStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum TreatmentStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
}

model User {
  id             String   @id @default(uuid())
  name           String
  email          String   @unique
  password       String
  role           UserRole
  branchId       String
  branch         Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  specialization String? // Doctor specialization (e.g., "Orthodontics", "Oral Surgery")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  appointmentsAsDentist        Appointment[]        @relation("DentistAppointments")
  appointmentsAsXray           Appointment[]        @relation("XrayAppointments")
  appointmentsAsReceptionist   Appointment[]        @relation("ReceptionistAppointments")
  detailedBillingEnabled        Payment[]            @relation("DetailedBillingEnabled")
  schedules                     DoctorSchedule[]
  availability                  DoctorAvailability[]
  notifications                 Notification[]       @relation("UserNotifications")
  notificationPreferences       NotificationPreference[] @relation("UserNotificationPreferences")

  @@index([email])
  @@index([branchId])
}

model Branch {
  id        String   @id @default(uuid())
  name      String
  code      String   @unique
  address   String
  taxNumber String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users           User[]
  appointments    Appointment[]
  doctorSchedules DoctorSchedule[]

  @@index([isActive])
}

model Patient {
  id          String    @id @default(uuid())
  name        String
  phone       String?
  email       String?
  gender      String? // Male, Female, Other
  dateOfBirth DateTime?
  address     String?
  cardNo      String? // Patient card/ID number
  notes       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  appointments Appointment[]

  @@index([name])
  @@index([phone])
  @@index([email])
  @@index([cardNo])
}

model Appointment {
  id            String            @id @default(uuid())
  patientId     String?
  patient       Patient?          @relation(fields: [patientId], references: [id], onDelete: SetNull)
  patientName   String // Keep for backward compatibility
  branchId      String
  branch        Branch            @relation(fields: [branchId], references: [id], onDelete: Cascade)
  dentistId     String
  dentist       User              @relation("DentistAppointments", fields: [dentistId], references: [id], onDelete: Cascade)
  xrayId        String?
  xray          User?             @relation("XrayAppointments", fields: [xrayId], references: [id], onDelete: SetNull)
  receptionistId String?
  receptionist  User?             @relation("ReceptionistAppointments", fields: [receptionistId], references: [id], onDelete: SetNull)
  date          DateTime
  status        AppointmentStatus @default(PENDING)
  visitReason   String? // Reason for visit / complaint
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  // Relations
  treatment  Treatment?
  xrayResult XRay?
  payment    Payment?

  @@index([branchId])
  @@index([dentistId])
  @@index([xrayId])
  @@index([receptionistId])
  @@index([date])
  @@index([status])
  @@index([patientName])
  @@index([patientId])
}

model Treatment {
  id            String          @id @default(uuid())
  appointmentId String          @unique
  appointment   Appointment     @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  diagnosis     String?
  treatmentPlan String?
  status        TreatmentStatus @default(PENDING)

  // SOAP Clinical Workflow Fields
  // Subjective
  chiefComplaint        String?
  historyPresentIllness String?
  medicalHistory        String?
  dentalHistory         String?
  socialHistory         String?

  // Objective - Structured Data (JSON)
  vitalSigns    Json? // {temperature, bpSystolic, bpDiastolic, pulseRate, respiratoryRate, weight, height}
  // Ethiopian Dental Clinic Format:
  // clinicalExam: {
  //   generalAppearance: {levelOfConsciousness, bodyBuildPosture, signsOfPainDistress, nutritionalStatus, pallorJaundiceCyanosis, facialSymmetry, swellingDeformity},
  //   extraOral: {faceSymmetry, faceSwelling, faceSinusTract, faceScars, eyesPallor, eyesJaundice, lipsColor, lipsCracks, lipsUlcers, tmjPain, tmjClicking, tmjLimitation, lymphNodesSubmental, lymphNodesSubmandibular, lymphNodesCervical},
  //   intraOral: {oralHygieneStatus, softTissueBuccalMucosa, softTissueLabialMucosa, gingivaColor, gingivaConsistency, gingivaBleeding, gingivaSwelling, palateHard, palateSoft, floorOfMouthSwelling, floorOfMouthTenderness, floorOfMouthLesions, tongueSizeShape, tongueColor, tongueCoating, tongueMovement, tongueLesions, dentalNumberPresent, dentalNumberMissing, dentalCaries, dentalFilled, dentalFractured, dentalMobility, dentalMalocclusion, dentalAttritionAbrasionErosion, periodontalPocketDepth, periodontalRecession},
  //   provisionalFindings: string,
  //   // Legacy: extraoralFindings, intraoralSoftTissue, periodontalStatus, occlusionFindings
  // }
  clinicalExam  Json? 
  clinicalTests Json? // {pulpVitality, percussion, thermalSensitivity, mobility}

  // Assessment
  diagnosisCode      String?
  secondaryDiagnoses String[] @default([])
  diagnosisNotes     String?

  // Plan - Structured Data
  affectedTeeth String[] @default([]) // Array of tooth numbers/letters (Universal notation)
  toolsUsed     String[] @default([]) // Array of tool IDs used
  procedureLogs Json? // Array of {code, description, tooth, duration, anesthesia, notes}
  postTreatment Json? // {painLevel, complications, instructions, medications, followUpDate}
  notes         String?
  dentistSignature String?
  totalCost     Decimal? // Total cost of treatment (calculated from procedures)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([appointmentId])
  @@index([status])
  @@index([diagnosisCode])
}

model XRay {
  id            String       @id @default(uuid())
  appointmentId String?      @unique
  appointment   Appointment? @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  result        String?
  imageUrl      String? // Deprecated: Keep for backward compatibility, use images relation instead
  sentToDentist Boolean     @default(false)

  // Enhanced X-Ray Fields
  xrayType  String? // PANORAMIC, BITEWING, PERIAPICAL, OCCLUSAL, CEPHALOMETRIC, CT_SCAN, CBCT
  teeth     String[] @default([]) // Array of tooth numbers/letters visible in X-Ray
  findings  Json? // Structured findings per tooth: [{tooth, findings, condition, recommendations}]
  technique String? // X-Ray technique used
  urgency   String? // Severity/Urgency rating

  // Relations
  images XRayImage[]
  shares XrayShare[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([appointmentId])
  @@index([sentToDentist])
  @@index([xrayType])
}

model XRayImage {
  id          String   @id @default(uuid())
  xrayId      String
  xray        XRay     @relation(fields: [xrayId], references: [id], onDelete: Cascade)
  imageUrl    String
  imageType   String? // PANORAMIC, BITEWING, PERIAPICAL, OCCLUSAL, CEPHALOMETRIC, CT_SCAN, CBCT
  description String?
  uploadedAt  DateTime @default(now())

  @@index([xrayId])
  @@index([imageType])
}

model XrayShare {
  id         String    @id @default(uuid())
  xrayId     String
  xray       XRay      @relation(fields: [xrayId], references: [id], onDelete: Cascade)
  shareToken String    @unique // Unique token for the share link
  password   String? // Optional password hash for password-protected shares
  expiresAt  DateTime? // Optional expiration date
  maxViews   Int? // Optional maximum number of views
  viewCount  Int       @default(0) // Track how many times it's been viewed
  isActive   Boolean   @default(true) // Can be deactivated without deleting
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  createdBy  String // User ID who created the share

  @@index([xrayId])
  @@index([shareToken])
  @@index([isActive])
}

model DoctorSchedule {
  id          String   @id @default(uuid())
  doctorId    String
  doctor      User     @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  branchId    String
  branch      Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  dayOfWeek   Int // 0 = Sunday, 1 = Monday, 2 = Tuesday, etc.
  startTime   String // Format: "HH:mm" (e.g., "09:00")
  endTime     String // Format: "HH:mm" (e.g., "17:00")
  isAvailable Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([doctorId, branchId, dayOfWeek])
  @@index([doctorId])
  @@index([branchId])
  @@index([dayOfWeek])
}

model DoctorAvailability {
  id          String   @id @default(uuid())
  doctorId    String
  doctor      User     @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  date        DateTime // Specific date (time component should be 00:00:00)
  startTime   String? // Format: "HH:mm" (optional, defaults to schedule start)
  endTime     String? // Format: "HH:mm" (optional, defaults to schedule end)
  reason      String? // Reason for availability change (e.g., "Vacation", "Sick", "Meeting")
  isAvailable Boolean  @default(false) // false = blocked/unavailable, true = available
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([doctorId])
  @@index([date])
  @@index([doctorId, date])
}

enum PaymentStatus {
  PAID
  PARTIAL
  UNPAID
}

model Payment {
  id                      String        @id @default(uuid())
  appointmentId            String        @unique
  appointment              Appointment   @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  amount                  Decimal       // Total amount due
  paidAmount              Decimal       @default(0) // Amount paid so far
  paymentStatus            PaymentStatus @default(UNPAID)
  paymentDate             DateTime?     // Date when payment was made/updated
  paymentMethod           String?       // Payment method: CASH, CARD, MOBILE, etc.
  showDetailedBilling     Boolean       @default(false) // Controls visibility of detailed billing section
  detailedBillingEnabledBy String?      // Dentist who enabled detailed billing
  detailedBillingEnabledByUser User?    @relation("DetailedBillingEnabled", fields: [detailedBillingEnabledBy], references: [id], onDelete: SetNull)
  isHidden                Boolean       @default(false) // Hidden payments (reception can toggle visibility)
  notes                   String?
  createdAt               DateTime      @default(now())
  updatedAt               DateTime      @updatedAt

  @@index([appointmentId])
  @@index([paymentStatus])
  @@index([paymentDate])
  @@index([showDetailedBilling])
  @@index([isHidden])
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

enum NotificationType {
  APPOINTMENT_CREATED
  APPOINTMENT_UPDATED
  APPOINTMENT_CANCELLED
  XRAY_READY
  XRAY_SENT
  PAYMENT_CREATED
  PAYMENT_UPDATED
  TREATMENT_COMPLETED
  TREATMENT_COST_UPDATED
  DETAILED_BILLING_ENABLED
}

enum NotificationLogEvent {
  SENT
  DELIVERED
  READ
  ACKNOWLEDGED
  FAILED
  ESCALATED
}

model Notification {
  id            String             @id @default(uuid())
  userId        String
  user          User               @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  type          NotificationType
  priority      NotificationPriority @default(NORMAL)
  title         String
  message       String
  eventId       String             @unique // UUID for idempotency
  version       String             @default("1.0")
  read          Boolean            @default(false)
  delivered     Boolean            @default(false)
  acknowledged  Boolean            @default(false)
  escalated     Boolean            @default(false)
  data          Json?              // Additional data (appointmentId, paymentId, etc.)
  actionUrl     String?            // Route to navigate on click
  expiresAt     DateTime?          // For time-sensitive notifications
  requiresAck   Boolean            @default(false)
  retryCount    Int                @default(0)
  maxRetries    Int                @default(3)
  createdAt     DateTime           @default(now())
  readAt        DateTime?
  deliveredAt   DateTime?
  acknowledgedAt DateTime?

  // Relations
  logs          NotificationLog[]

  @@index([userId])
  @@index([type])
  @@index([priority])
  @@index([read])
  @@index([delivered])
  @@index([createdAt])
  @@index([eventId])
}

model NotificationPreference {
  id              String           @id @default(uuid())
  userId          String
  user            User             @relation("UserNotificationPreferences", fields: [userId], references: [id], onDelete: Cascade)
  notificationType NotificationType
  enabled         Boolean          @default(true)
  soundEnabled    Boolean          @default(true)
  toastEnabled     Boolean          @default(true)
  workHoursStart  String?          // Format: "HH:mm" (e.g., "09:00")
  workHoursEnd    String?          // Format: "HH:mm" (e.g., "17:00")
  doNotDisturb    Boolean          @default(false)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@unique([userId, notificationType])
  @@index([userId])
  @@index([notificationType])
}

model NotificationLog {
  id             String              @id @default(uuid())
  notificationId String
  notification   Notification        @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  event          NotificationLogEvent
  timestamp      DateTime            @default(now())
  metadata       Json?               // Additional event metadata

  @@index([notificationId])
  @@index([event])
  @@index([timestamp])
}
