// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

// Note: The datasource url property is supported in Prisma 5.x (version 5.22.0)
// The linter warning about Prisma 7 is a false positive - this is the correct syntax for Prisma 5.x
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  RECEPTION
  DENTIST
  XRAY
}

enum AppointmentStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum TreatmentStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
}

model User {
  id                  String   @id @default(uuid())
  name                String
  email               String   @unique
  password            String
  role                UserRole
  branchId            String
  branch              Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  specialization      String? // Doctor specialization (e.g., "Orthodontics", "Oral Surgery")
  passwordChanged     Boolean  @default(false) // Track if user has changed password from default
  firstLoginCompleted Boolean  @default(false) // Track if first login with default credentials has been completed
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Password tracking and admin visibility
  createdBy                 String? // ID of admin who created the user
  createdByUser             User?     @relation("UserCreatedBy", fields: [createdBy], references: [id], onDelete: SetNull)
  usersCreated              User[]    @relation("UserCreatedBy")
  passwordChangedBy         String? // ID of user/admin who last changed password
  passwordChangedByUser     User?     @relation("UserPasswordChangedBy", fields: [passwordChangedBy], references: [id], onDelete: SetNull)
  usersPasswordChanged      User[]    @relation("UserPasswordChangedBy")
  passwordChangedAt         DateTime? // Timestamp of last password change
  adminVisiblePassword      String? // AES-encrypted plaintext password for admin view
  passwordChangedByUserFlag Boolean   @default(false) // Flag indicating if password was changed by user (true) or admin (false)

  // Relations
  appointmentsAsDentist      Appointment[]        @relation("DentistAppointments")
  appointmentsAsXray         Appointment[]        @relation("XrayAppointments")
  appointmentsAsReceptionist Appointment[]        @relation("ReceptionistAppointments")
  detailedBillingEnabled     Payment[]            @relation("DetailedBillingEnabled")
  schedules                  DoctorSchedule[]
  availability               DoctorAvailability[]
  auditLogs                  AuditLog[]

  @@index([email])
  @@index([branchId])
  @@index([createdBy])
  @@index([passwordChangedBy])
}

model Branch {
  id        String   @id @default(uuid())
  name      String
  code      String   @unique
  address   String
  taxNumber String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users           User[]
  appointments    Appointment[]
  doctorSchedules DoctorSchedule[]
  workingHours    BranchWorkingHours[]
  auditLogs       AuditLog[]

  @@index([isActive])
}

model Patient {
  id          String    @id @default(uuid())
  name        String
  phone       String?
  email       String?
  gender      String? // Male, Female, Other
  dateOfBirth DateTime?
  address     String?
  cardNo      String? // Patient card/ID number
  notes       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  appointments Appointment[]

  @@index([name])
  @@index([phone])
  @@index([email])
  @@index([cardNo])
}

model Appointment {
  id             String            @id @default(uuid())
  patientId      String // REQUIRED: Every appointment must be linked to a patient
  patient        Patient           @relation(fields: [patientId], references: [id], onDelete: Cascade)
  patientName    String // Keep for backward compatibility (derived from patient.name)
  branchId       String
  branch         Branch            @relation(fields: [branchId], references: [id], onDelete: Cascade)
  dentistId      String
  dentist        User              @relation("DentistAppointments", fields: [dentistId], references: [id], onDelete: Cascade)
  xrayId         String?
  xray           User?             @relation("XrayAppointments", fields: [xrayId], references: [id], onDelete: SetNull)
  receptionistId String?
  receptionist   User?             @relation("ReceptionistAppointments", fields: [receptionistId], references: [id], onDelete: SetNull)
  date           DateTime
  status         AppointmentStatus @default(PENDING)
  visitReason    String? // Reason for visit / complaint
  xrayType       String? // Investigation/X-Ray Type requested by dentist
  urgency        String? // Urgency level (NORMAL, URGENT, STAT)
  notes          String? // Notes/Instructions from dentist for X-Ray doctor
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  // Relations
  treatments Treatment[]
  xrayResult XRay?
  payments   Payment[] // Changed from Payment? to Payment[] to allow multiple payments

  @@index([branchId])
  @@index([dentistId])
  @@index([xrayId])
  @@index([receptionistId])
  @@index([date])
  @@index([status])
  @@index([patientName])
  @@index([patientId])
}

model Treatment {
  id            String          @id @default(uuid())
  appointmentId String
  appointment   Appointment     @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  diagnosis     String?
  treatmentPlan String?
  status        TreatmentStatus @default(PENDING)

  // SOAP Clinical Workflow Fields
  // Subjective
  chiefComplaint        String?
  historyPresentIllness String?
  medicalHistory        String?
  dentalHistory         String?
  socialHistory         String?

  // Objective - Structured Data (JSON)
  vitalSigns     Json? // {temperature, bpSystolic, bpDiastolic, pulseRate, respiratoryRate, weight, height}
  // Ethiopian Dental Clinic Format:
  // clinicalExam: {
  //   generalAppearance: {levelOfConsciousness, bodyBuildPosture, signsOfPainDistress, nutritionalStatus, pallorJaundiceCyanosis, facialSymmetry, swellingDeformity},
  //   extraOral: {faceSymmetry, faceSwelling, faceSinusTract, faceScars, eyesPallor, eyesJaundice, lipsColor, lipsCracks, lipsUlcers, tmjPain, tmjClicking, tmjLimitation, lymphNodesSubmental, lymphNodesSubmandibular, lymphNodesCervical},
  //   intraOral: {oralHygieneStatus, softTissueBuccalMucosa, softTissueLabialMucosa, gingivaColor, gingivaConsistency, gingivaBleeding, gingivaSwelling, palateHard, palateSoft, floorOfMouthSwelling, floorOfMouthTenderness, floorOfMouthLesions, tongueSizeShape, tongueColor, tongueCoating, tongueMovement, tongueLesions, dentalNumberPresent, dentalNumberMissing, dentalCaries, dentalFilled, dentalFractured, dentalMobility, dentalMalocclusion, dentalAttritionAbrasionErosion, periodontalPocketDepth, periodontalRecession},
  //   provisionalFindings: string,
  //   // Legacy: extraoralFindings, intraoralSoftTissue, periodontalStatus, occlusionFindings
  // }
  clinicalExam   Json?
  clinicalTests  Json? // {pulpVitality, percussion, thermalSensitivity, mobility}
  investigations Json? // {types: [], other: ""} - X-Ray/Investigation types and custom notes

  // Assessment
  diagnosisCode      String?
  secondaryDiagnoses String[] @default([])
  diagnosisNotes     String?

  // Plan - Structured Data
  affectedTeeth    String[] @default([]) // Array of tooth numbers/letters (Universal notation)
  toolsUsed        String[] @default([]) // Array of tool IDs used
  procedureLogs    Json? // Array of {code, description, tooth, duration, anesthesia, notes}
  postTreatment    Json? // {painLevel, complications, instructions, medications, followUpDate}
  notes            String?
  dentistSignature String?
  totalCost        Decimal? // Total cost of treatment (calculated from procedures)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([appointmentId])
  @@index([status])
  @@index([diagnosisCode])
}

model XRay {
  id            String       @id @default(uuid())
  appointmentId String?      @unique
  appointment   Appointment? @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  result        String?
  imageUrl      String? // Deprecated: Keep for backward compatibility, use images relation instead
  sentToDentist Boolean      @default(false)

  // Enhanced X-Ray Fields
  xrayType  String? // PANORAMIC, BITEWING, PERIAPICAL, OCCLUSAL, CEPHALOMETRIC, CT_SCAN, CBCT
  teeth     String[] @default([]) // Array of tooth numbers/letters visible in X-Ray
  findings  Json? // X-Ray findings data (flexible JSON structure)
  technique String? // X-Ray technique used
  urgency   String? // Severity/Urgency rating

  // Relations
  images XRayImage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([appointmentId])
  @@index([sentToDentist])
  @@index([xrayType])
}

model XRayImage {
  id          String   @id @default(uuid())
  xrayId      String
  xray        XRay     @relation(fields: [xrayId], references: [id], onDelete: Cascade)
  imageUrl    String
  imageType   String? // PANORAMIC, BITEWING, PERIAPICAL, OCCLUSAL, CEPHALOMETRIC, CT_SCAN, CBCT
  description String?
  uploadedAt  DateTime @default(now())

  @@index([xrayId])
  @@index([imageType])
}

model DoctorSchedule {
  id          String   @id @default(uuid())
  doctorId    String
  doctor      User     @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  branchId    String
  branch      Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  dayOfWeek   Int // 0 = Sunday, 1 = Monday, 2 = Tuesday, etc.
  startTime   String // Format: "HH:mm" (e.g., "09:00")
  endTime     String // Format: "HH:mm" (e.g., "17:00")
  isAvailable Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([doctorId, branchId, dayOfWeek])
  @@index([doctorId])
  @@index([branchId])
  @@index([dayOfWeek])
}

model DoctorAvailability {
  id          String   @id @default(uuid())
  doctorId    String
  doctor      User     @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  date        DateTime // Specific date (time component should be 00:00:00)
  startTime   String? // Format: "HH:mm" (optional, defaults to schedule start)
  endTime     String? // Format: "HH:mm" (optional, defaults to schedule end)
  reason      String? // Reason for availability change (e.g., "Vacation", "Sick", "Meeting")
  isAvailable Boolean  @default(false) // false = blocked/unavailable, true = available
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([doctorId])
  @@index([date])
  @@index([doctorId, date])
}

enum PaymentStatus {
  PAID
  PARTIAL
  UNPAID
}

model Payment {
  id                           String        @id @default(uuid())
  appointmentId                String // Removed @unique to allow multiple payments per appointment
  appointment                  Appointment   @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  amount                       Decimal // Total amount due
  paidAmount                   Decimal       @default(0) // Amount paid so far
  paymentStatus                PaymentStatus @default(UNPAID)
  paymentDate                  DateTime? // Date when payment was made/updated
  paymentMethod                String? // Payment method: CASH, CARD, MOBILE, etc.
  showDetailedBilling          Boolean       @default(false) // Controls visibility of detailed billing section
  detailedBillingEnabledBy     String? // Dentist who enabled detailed billing
  detailedBillingEnabledByUser User?         @relation("DetailedBillingEnabled", fields: [detailedBillingEnabledBy], references: [id], onDelete: SetNull)
  isHidden                     Boolean       @default(false) // Hidden payments (reception can toggle visibility)
  notes                        String?
  createdAt                    DateTime      @default(now())
  updatedAt                    DateTime      @updatedAt

  @@index([appointmentId])
  @@index([paymentStatus])
  @@index([paymentDate])
  @@index([showDetailedBilling])
  @@index([isHidden])
}

model BranchWorkingHours {
  id        String   @id @default(uuid())
  branchId  String
  branch    Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  dayOfWeek Int // 0-6 (Sunday-Saturday)
  startTime String // HH:mm format
  endTime   String // HH:mm format
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, dayOfWeek, startTime])
  @@index([branchId])
}

model AuditLog {
  id         String   @id @default(uuid())
  userId     String? // User who performed the action (nullable to preserve audit trail when user is deleted)
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  action     String // CREATE, UPDATE, DELETE, LOGIN, etc.
  entityType String // User, Appointment, Treatment, Payment, etc.
  entityId   String? // ID of affected entity
  branchId   String? // Branch context
  branch     Branch?  @relation(fields: [branchId], references: [id], onDelete: SetNull)
  oldData    Json? // Previous state (for updates/deletes)
  newData    Json? // New state (for creates/updates)
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([entityType, entityId])
  @@index([branchId])
  @@index([createdAt])
}
